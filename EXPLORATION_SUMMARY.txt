================================================================================
                    ETHERCHIMP CODEBASE EXPLORATION SUMMARY
================================================================================

PROJECT: Real-time Network Traffic Visualization and Analysis Tool
LANGUAGE: Python Backend + JavaScript Frontend
STATUS: Complete exploration with comprehensive documentation

================================================================================
FINDINGS OVERVIEW
================================================================================

1. PROJECT STRUCTURE IDENTIFIED:
   - Flask 3.1.2 web application with WebSocket support (Socket.IO)
   - Vanilla JavaScript frontend (no frameworks, ~4,720 lines)
   - Python Scapy-based backend for packet processing
   - 300px left sidebar + canvas-based visualization area
   - Two floating info panels (bottom-left metrics, bottom-right timeline)

2. DASHBOARD PANELS LOCATED:

   LEFT SIDEBAR (#sidebar):
   - Header with logo and subtitle
   - Upload area for PCAP files
   - Traffic Overview stats (Total Packets, Unique Hosts, Active Connections)
   - Data Analysis stats (Volume, Avg Size, Protocol Count)
   - Security Alerts section with expandable panel
   - Updates: File mode (once), Live mode (every 2 seconds)

   BOTTOM-LEFT INFO PANEL (#infoPanel):
   - Real-time metrics display (Packets/sec, Bandwidth, Flows, Threats)
   - Selected packet data section (hidden by default)
   - Position: absolute, 300px min-width
   - Updates: File mode (once), Live mode (every 2 seconds via scheduleUIUpdate)

   BOTTOM-RIGHT TIMELINE PANEL (#timelineContainer):
   - Timeline slider with draggable handle
   - Current time display and start/end labels
   - Position: absolute, 400px min-width
   - Hidden in file mode, active during live capture

3. DATA FLOW MECHANISMS:

   FILE UPLOAD MODE:
   - User drops PCAP file on upload area
   - POST /upload to backend
   - Backend runs pcap_processor.process_pcap()
   - Returns JSON with summary + hosts + connections + packets + alerts
   - Frontend updates parser.summary object
   - updateStats() called once to populate UI
   - All stats displayed immediately

   LIVE CAPTURE MODE:
   - User configures interface or socket auto-starts on connection
   - emit('start_capture') sent to backend
   - Backend spawns LiveCapture instance with 3 threads:
     * Capture thread (scapy.sniff)
     * Batch sender thread (emits every 2 seconds)
     * DNS resolver thread (background hostname lookup)
   - packet_batch event emitted every 2 seconds with:
     * Up to 100 packets
     * Pre-aggregated nodes with stats
     * Pre-aggregated edges (connections)
     * DNS cache updates
   - Frontend processes batch:
     * Updates visualizer nodes/edges
     * Appends packets to parser
     * Calls scheduleUIUpdate() via requestAnimationFrame
   - UI updates every 2 seconds (batch interval)

4. REAL-TIME UPDATE MECHANISMS:

   WebSocket (Socket.IO):
   - packet_batch event (every 2 seconds) - PRIMARY UPDATE
   - capture_started, capture_stopped, capture_restarted
   - interface_ready, pcap_saved, capture_error

   Polling with setInterval:
   - Stream list update (1 second) during live capture
   - Playback animation (if timeline playing)

   RequestAnimationFrame:
   - scheduleUIUpdate() batches DOM updates
   - Updates synchronized with browser 60fps
   - Prevents thrashing from rapid batch arrivals

   Canvas Animation Loop:
   - Continuous 60fps rendering of network graph
   - Physics simulation for node movement
   - Particle effects for traffic visualization

5. BACKEND ENDPOINTS:

   HTTP:
   - GET /                  → Main HTML interface
   - POST /upload           → PCAP file processing
   - GET /autoload          → Auto-load configuration

   WebSocket Events (SocketIO):
   - Server sends: packet_batch, capture_started, capture_stopped, etc.
   - Frontend sends: start_capture, stop_capture, save_and_restart_capture

6. METRIC CALCULATIONS:

   Backend (preferred for live mode):
   - Packets/sec = total packets / duration
   - Bandwidth = (total bytes * 8 / duration) / 1,000,000 Mbps
   - Active Flows = count of unique connections
   - Threats = count of security alerts detected
   - Data Volume = total bytes / 1,048,576 MB
   - Avg Packet Size = total bytes / total packets

   Frontend display:
   - Uses parser.summary object populated from backend
   - Updates via updateStats() function in ui-updaters.js
   - Displays with proper formatting (localization, units, colors)

7. PERFORMANCE OPTIMIZATIONS:

   Frontend:
   - Max 10,000 packets stored (removes oldest 1,000 when exceeded)
   - Max 500 nodes in visualizer (prevents performance degradation)
   - Max 100 packets per batch (limits network/processing load)
   - Canvas-based rendering instead of DOM

   Backend:
   - Pre-aggregates nodes and edges on backend
   - Batch sender thread combines packets every 2 seconds
   - DNS resolution in background thread
   - Threat detection in-stream (no separate pass)

   Network:
   - WebSocket instead of polling (lower latency)
   - 2-second batching (60x fewer events vs per-packet)
   - Pre-aggregated data (smaller payloads)

8. KEY FILES AND LOCATIONS:

   Backend:
   - /opt/bc_ctf-Etherchimp/app.py (102 lines)
   - /opt/bc_ctf-Etherchimp/backend/routes/api.py (247 lines)
   - /opt/bc_ctf-Etherchimp/backend/processing/pcap_processor.py (219 lines)
   - /opt/bc_ctf-Etherchimp/backend/processing/live_capture.py (376 lines)

   Frontend:
   - /opt/bc_ctf-Etherchimp/templates/run.html (277 lines)
   - /opt/bc_ctf-Etherchimp/static/js/app.js (4720 lines)
   - /opt/bc_ctf-Etherchimp/static/js/modules/ui-updaters.js (72 lines)
   - /opt/bc_ctf-Etherchimp/static/css/styles.css (2111 lines)

9. THREAT DETECTION CAPABILITIES:

   - Port Scanning (10+ unique destination ports)
   - IP Address Changes / ARP Spoofing (MAC/IP mapping changes)
   - Multiple IP Addresses (single MAC using 3+ IPs)
   - Suspicious Port Activity (backdoor ports: 4444, 5555, 6666, 7777, 31337, 12345)
   - ICMP Flooding (50+ ICMP packets in 1 second)
   - Connection Failures (20+ RST packets)

================================================================================
DOCUMENTATION GENERATED
================================================================================

1. CODEBASE_EXPLORATION.md (629 lines, 21KB)
   - Complete project overview
   - Technology stack details
   - Dashboard panels and UI components description
   - Real-time update mechanisms (WebSocket, polling, requestAnimationFrame)
   - Data flow diagrams for file upload and live capture modes
   - Backend endpoints and WebSocket events
   - Parser and threat detection details
   - Performance optimization strategies
   - Key files reference

2. ARCHITECTURE.md (365 lines, 21KB)
   - High-level system architecture diagram
   - Data flow diagrams (file upload and live capture)
   - Frontend data state management structures
   - UI update frequency comparison table
   - Performance optimization points breakdown
   - Key file dependencies mapping

3. QUICK_REFERENCE.md (480 lines, 12KB)
   - Panel locations with element IDs
   - Update functions quick lookup
   - Metric calculations reference
   - Socket.IO events documentation
   - CSS classes for styling
   - Backend endpoints summary
   - Global variables reference
   - Common data structures
   - Performance limits
   - Debugging tips
   - Common modifications guide

================================================================================
KEY DISCOVERIES
================================================================================

1. DUAL UPDATE PATHS:
   - File mode: Single JSON response with all data
   - Live mode: Continuous 2-second batches via WebSocket

2. INTELLIGENT BATCHING:
   - Backend pre-aggregates nodes/edges
   - Frontend uses requestAnimationFrame for UI updates
   - Prevents DOM thrashing while maintaining responsiveness

3. MEMORY MANAGEMENT:
   - 10,000 packet limit (rolling buffer)
   - 500 node limit (prevents visualization overload)
   - Per-node/edge packet limits (100 packets)
   - Automatic cleanup when limits exceeded

4. REAL-TIME CAPABILITIES:
   - WebSocket for bi-directional communication
   - 2-second batch interval (configurable)
   - Live DNS resolution in background
   - Threat detection during capture

5. VISUALIZATION DESIGN:
   - Canvas-based 2D/3D rendering (much faster than DOM)
   - Force-directed layout with physics simulation
   - Particle effects for traffic visualization
   - 60fps continuous animation

================================================================================
FILES LOCATION SUMMARY
================================================================================

Project Root: /opt/bc_ctf-Etherchimp/

Documentation Generated:
- ./CODEBASE_EXPLORATION.md    ← Comprehensive technical analysis
- ./ARCHITECTURE.md             ← System architecture and data flows
- ./QUICK_REFERENCE.md          ← Quick lookup guide and snippets
- ./EXPLORATION_SUMMARY.txt     ← This file

Source Code:
- ./app.py                      ← Main Flask application
- ./backend/routes/api.py       ← API endpoints and SocketIO handlers
- ./backend/processing/         ← Packet processing modules
- ./templates/run.html          ← Main UI template
- ./static/js/app.js            ← Main JavaScript application
- ./static/js/modules/          ← JavaScript module files
- ./static/css/styles.css       ← Complete styling

================================================================================
NEXT STEPS FOR DEVELOPER
================================================================================

1. Start with QUICK_REFERENCE.md for immediate lookups
2. Refer to CODEBASE_EXPLORATION.md for detailed understanding
3. Check ARCHITECTURE.md for data flow and system design
4. Read inline comments in source files for implementation details

Key files to examine:
1. app.py - Flask configuration and SocketIO setup
2. static/js/app.js - Main application logic (4720 lines, comprehensive)
3. static/js/modules/ui-updaters.js - Panel update functions
4. backend/processing/live_capture.py - Live capture implementation
5. templates/run.html - UI structure and element IDs

================================================================================
EXPLORATION COMPLETE
================================================================================

All major components of the EtherChimp codebase have been explored and
documented. The project structure, UI panels, data flow mechanisms, and
real-time update strategies are now fully understood.

Ready for:
- Feature development
- Performance optimization
- Bug fixes
- Integration with other systems
- Dashboard panel modifications

Generated by: Codebase Exploration Tool
Date: 2025-11-12
Time: 10:35 UTC

================================================================================
